# Enhanced merge conflict resolution
# Enhanced merge conflict resolution
handle_merge_conflict() {
    if ! git status --porcelain | grep -q "^UU\|^AA\|^DD"; then
        return 0
    fi
    
    echo "\033[31mâš ï¸ Merge conflicts detected!\033[0m"
    
    local conflict_files=$(git status --porcelain | grep "^UU\|^AA\|^DD" | awk '{print $2}')
    local conflict_count=$(echo "$conflict_files" | wc -l)
    
    echo "\033[33mğŸ“ Found $conflict_count conflicted file(s):\033[0m"
    echo "$conflict_files" | sed 's/^/  /'
    
    local conflict_tool=$(echo -e "ğŸ”§ mergetool\nğŸš€ gitClient (per file)\nğŸš€ gitClient (project)\nğŸ™ GitHub Desktop\nğŸ’» VSCode\nâœ‹ Handle manually\nâŒ Abort merge" | \
        fzf --prompt "ğŸ¯ Choose conflict resolution tool: ")
    
    case "$conflict_tool" in
        "ğŸ”§ mergetool")
            git mergetool
            ;;
        "ğŸš€ gitClient (per file)")
            if command -v gitclient >/dev/null 2>&1; then
                echo "$conflict_files" | while read -r file; do
                    if [[ -n "$file" ]]; then
                        echo "\033[36mğŸ”€ Resolving conflicts in: $file\033[0m"
                        
                        # Create temporary files for the different versions
                        local temp_dir=$(mktemp -d)
                        local local_file="$temp_dir/local_$(basename "$file")"
                        local remote_file="$temp_dir/remote_$(basename "$file")"
                        local base_file="$temp_dir/base_$(basename "$file")"
                        
                        # Extract the different versions from git index
                        git show ":2:$file" > "$local_file" 2>/dev/null || touch "$local_file"
                        git show ":3:$file" > "$remote_file" 2>/dev/null || touch "$remote_file"
                        git show ":1:$file" > "$base_file" 2>/dev/null || touch "$base_file"
                        
                        # Use gitClient merge command (suppress JB internal warnings)
                        if [[ -s "$base_file" ]]; then
                            gitclient merge "$local_file" "$remote_file" "$base_file" "$file" 2>/dev/null
                        else
                            gitclient merge "$local_file" "$remote_file" "$file" 2>/dev/null
                        fi
                        
                        # Clean up temp files
                        rm -rf "$temp_dir"
                        
                        # Mark as resolved if user saved the file
                        if ! grep -q "<<<<<<< HEAD\|=======\|>>>>>>>" "$file" 2>/dev/null; then
                            git add "$file"
                            echo "\033[32mâœ… Marked $file as resolved\033[0m"
                        fi
                    fi
                done
            elif command -v git-client >/dev/null 2>&1; then
                echo "$conflict_files" | while read -r file; do
                    if [[ -n "$file" ]]; then
                        echo "\033[36mğŸ”€ Resolving conflicts in: $file\033[0m"
                        
                        local temp_dir=$(mktemp -d)
                        local local_file="$temp_dir/local_$(basename "$file")"
                        local remote_file="$temp_dir/remote_$(basename "$file")"
                        local base_file="$temp_dir/base_$(basename "$file")"
                        
                        git show ":2:$file" > "$local_file" 2>/dev/null || touch "$local_file"
                        git show ":3:$file" > "$remote_file" 2>/dev/null || touch "$remote_file"
                        git show ":1:$file" > "$base_file" 2>/dev/null || touch "$base_file"
                        
                        if [[ -s "$base_file" ]]; then
                            git-client merge "$local_file" "$remote_file" "$base_file" "$file" 2>/dev/null
                        else
                            git-client merge "$local_file" "$remote_file" "$file" 2>/dev/null
                        fi
                        
                        rm -rf "$temp_dir"
                        
                        if ! grep -q "<<<<<<< HEAD\|=======\|>>>>>>>" "$file" 2>/dev/null; then
                            git add "$file"
                            echo "\033[32mâœ… Marked $file as resolved\033[0m"
                        fi
                    fi
                done
            else
                echo "\033[31mâŒ JetBrains gitClient not found\033[0m"
            fi
            ;;
        "ğŸš€ gitClient (project)")
            if command -v gitclient >/dev/null 2>&1; then
                gitclient . 2>/dev/null &
            elif command -v git-client >/dev/null 2>&1; then
                git-client . 2>/dev/null &
            else
                echo "\033[31mâŒ JetBrains gitClient not found\033[0m"
            fi
            ;;
        "ğŸ™ GitHub Desktop")
            if command -v github >/dev/null 2>&1; then
                github .
            else
                echo "\033[31mâŒ GitHub Desktop not found\033[0m"
            fi
            ;;
        "ğŸ’» VSCode")
            if command -v code >/dev/null 2>&1; then
                code .
            else
                echo "\033[31mâŒ VSCode not found\033[0m"
            fi
            ;;
        "âœ‹ Handle manually")
            echo "\033[33mğŸ“ Conflict files:\033[0m"
            echo "$conflict_files" | sed 's/^/  /'
            ;;
        "âŒ Abort merge")
            git merge --abort
            echo "\033[31mâŒ Merge aborted\033[0m"
            ;;
    esac
}

git_stash() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "\033[31mâŒ Not in a git repository\033[0m"
        return 1
    fi

    local stashes=$(git stash list --format="%gd|%s|%cr" 2>/dev/null)
    
    if [[ -z "$stashes" ]]; then
        local action=$(echo -e "ğŸ’¾ Create new stash\nğŸ’¾ Create stash with message\nâŒ Cancel" | \
            fzf --prompt "ğŸ“¦ No stashes found: ")
        
        case "$action" in
            "ğŸ’¾ Create new stash")
                echo "\033[32mğŸ’¾ Creating stash...\033[0m"
                git stash
                ;;
            "ğŸ’¾ Create stash with message")
                echo "\033[33mğŸ’¡ Enter stash message:\033[0m"
                local stash_message=""
                vared stash_message
                if [[ -n "$stash_message" ]]; then
                    git stash push -m "$stash_message"
                    echo "\033[32mğŸ’¾ Created stash: $stash_message\033[0m"
                fi
                ;;
        esac
        return 0
    fi
    
    local selection=$(echo "$stashes" | \
        while IFS='|' read -r stash_ref message time; do
            printf "\033[36m%s\033[0m %s \033[90m(%s)\033[0m\n" "$stash_ref" "$message" "$time"
        done | \
        fzf --ansi \
            --prompt "ğŸ“¦ Select stash: " \
            --header $'\033[36m>> ğŸ’¾ Press TAB to create new stash <<\033[0m' \
            --preview 'git stash show -p $(echo {} | awk "{print \$1}") 2>/dev/null || echo "ğŸ“ No diff available"' \
            --preview-window=right:60% \
            --bind 'tab:print-query' \
            --print-query)
    
    local query=$(echo "$selection" | head -1)
    local choice=$(echo "$selection" | tail -1)
    
    if [[ -z "$choice" && -n "$query" ]] || [[ "$choice" == "$query" ]]; then
        if [[ -n "$query" ]]; then
            echo "\033[32mğŸ’¾ Creating stash with message: $query\033[0m"
            git stash push -m "$query"
        fi
        return 0
    fi
    
    [[ -z "$choice" ]] && return 0
    
    local stash_ref=$(echo "$choice" | awk '{print $1}')
    [[ -z "$stash_ref" ]] && return 0
    
    local action=$(echo -e "âœ… Apply stash\nğŸ¯ Pop stash\nğŸŒ¿ Create branch from stash\nğŸ—‘ï¸ Drop stash\nğŸ‘ï¸ Show stash details\nğŸ’¾ Create new stash\nâŒ Cancel" | \
        fzf --prompt "ğŸ¯ Action for '$stash_ref': ")
    
    case "$action" in
        "âœ… Apply stash")
            echo "\033[32mâœ… Applying stash: $stash_ref\033[0m"
            git stash apply "$stash_ref"
            ;;
        "ğŸ¯ Pop stash")
            echo "\033[32mğŸ¯ Popping stash: $stash_ref\033[0m"
            git stash pop "$stash_ref"
            ;;
        "ğŸŒ¿ Create branch from stash")
            echo "\033[33mğŸ’¡ Enter branch name for stash $stash_ref:\033[0m"
            local branch_name=""
            vared branch_name
            if [[ -n "$branch_name" ]]; then
                branch_name="${branch_name// /-}"
                echo "\033[32mğŸŒ¿ Creating branch '$branch_name' from stash $stash_ref\033[0m"
                git stash branch "$branch_name" "$stash_ref"
            fi
            ;;
        "ğŸ—‘ï¸ Drop stash")
            echo "\033[31mğŸ—‘ï¸ Dropping stash: $stash_ref\033[0m"
            git stash drop "$stash_ref"
            ;;
        "ğŸ‘ï¸ Show stash details")
            git stash show -p "$stash_ref" | less
            ;;
        "ğŸ’¾ Create new stash")
            echo "\033[33mğŸ’¡ Enter stash message (or leave empty for auto message):\033[0m"
            local stash_message=""
            vared stash_message
            if [[ -n "$stash_message" ]]; then
                git stash push -m "$stash_message"
            else
                git stash
            fi
            ;;
    esac
}

git_stage() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "\033[31mâŒ Not in a git repository\033[0m"
        return 1
    fi

    local files=$(git status --porcelain | \
        while read -r status file; do
            local color="\033[31m"
            local emoji="ğŸ“"
            case "$status" in
                "M ") color="\033[32m"; emoji="âœ…" ;;
                " M") color="\033[33m"; emoji="âš ï¸ " ;;
                "MM") color="\033[35m"; emoji="ğŸ”„" ;;
                "A ") color="\033[32m"; emoji="â•" ;;
                " A") color="\033[33m"; emoji="ğŸ“„" ;;
                "D ") color="\033[31m"; emoji="ğŸ—‘ï¸" ;;
                " D") color="\033[31m"; emoji="âŒ" ;;
                "??") color="\033[36m"; emoji="â“" ;;
                "!!") color="\033[90m"; emoji="ğŸš«" ;;
            esac
            printf "%s%s %s %s\033[0m\n" "$color" "$emoji" "$status" "$file"
        done)
    
    if [[ -z "$files" ]]; then
        echo "\033[32mâœ¨ Working directory clean\033[0m"
        return 0
    fi
    
    local selection=$(echo "$files" | \
        fzf --ansi \
            --multi \
            --prompt "ğŸ“ Select files (TAB for multi-select): " \
            --header $'\033[36m>> âœ…=staged âš ï¸=modified ğŸ“„=new âŒ=deleted <<\033[0m' \
            --preview 'git diff --color=always $(echo {} | awk "{print \$3}") 2>/dev/null || git diff --cached --color=always $(echo {} | awk "{print \$3}") 2>/dev/null || echo "ğŸ“ Binary file or no diff"' \
            --preview-window=right:60%)
    
    [[ -z "$selection" ]] && return 0
    
    local action=$(echo -e "â• Stage selected files\nâ– Unstage selected files\nğŸ¯ Stage hunks interactively\nğŸ’» Commit staged files\nğŸ—‘ï¸ Discard changes\nâŒ Cancel" | \
        fzf --prompt "ğŸ¯ Action for selected files: ")
    
    local file_list=$(echo "$selection" | awk '{print $3}' | tr '\n' ' ')
    
    case "$action" in
        "â• Stage selected files")
            echo "\033[32mâ• Staging files...\033[0m"
            echo "$selection" | awk '{print $3}' | xargs git add
            ;;
        "â– Unstage selected files")
            echo "\033[33mâ– Unstaging files...\033[0m"
            echo "$selection" | awk '{print $3}' | xargs git reset HEAD --
            ;;
        "ğŸ¯ Stage hunks interactively")
            echo "\033[35mğŸ¯ Interactive staging...\033[0m"
            echo "$selection" | awk '{print $3}' | xargs git add -p
            ;;
        "ğŸ’» Commit staged files")
            local staged=$(git diff --cached --name-only)
            if [[ -z "$staged" ]]; then
                echo "\033[31mâŒ No staged files to commit\033[0m"
                return 1
            fi
            echo "\033[33mğŸ’¡ Enter commit message:\033[0m"
            local commit_message=""
            vared commit_message
            if [[ -n "$commit_message" ]]; then
                git commit -m "$commit_message"
                echo "\033[32mâœ… Committed successfully\033[0m"
            fi
            ;;
        "ğŸ—‘ï¸ Discard changes")
            echo "\033[31mâš ï¸  WARNING: This will permanently discard changes!\033[0m"
            echo "\033[31mğŸ”¥ Type 'DISCARD' to confirm:\033[0m"
            local confirm=""
            vared confirm
            if [[ "$confirm" == "DISCARD" ]]; then
                echo "\033[31mğŸ—‘ï¸ Discarding changes...\033[0m"
                echo "$selection" | awk '{print $3}' | xargs git checkout --
            else
                echo "\033[33mâŒ Discard cancelled\033[0m"
            fi
            ;;
    esac
}

git_tags() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "\033[31mâŒ Not in a git repository\033[0m"
        return 1
    fi

    local tags=$(git tag -l --format='%(refname:short)|%(objectname:short)|%(creatordate:relative)' --sort=-creatordate 2>/dev/null)
    
    if [[ -z "$tags" ]]; then
        local action=$(echo -e "ğŸ·ï¸ Create new tag\nğŸ·ï¸ Create annotated tag\nâŒ Cancel" | \
            fzf --prompt "ğŸ·ï¸ No tags found: ")
        
        case "$action" in
            "ğŸ·ï¸ Create new tag")
                echo "\033[33mğŸ’¡ Enter tag name:\033[0m"
                local tag_name=""
                vared tag_name
                if [[ -n "$tag_name" ]]; then
                    tag_name="${tag_name// /-}"
                    git tag "$tag_name"
                    echo "\033[32mğŸ·ï¸ Created tag: $tag_name\033[0m"
                fi
                ;;
            "ğŸ·ï¸ Create annotated tag")
                echo "\033[33mğŸ’¡ Enter tag name:\033[0m"
                local tag_name=""
                vared tag_name
                if [[ -n "$tag_name" ]]; then
                    tag_name="${tag_name// /-}"
                    echo "\033[33mğŸ’¡ Enter tag message:\033[0m"
                    local tag_message=""
                    vared tag_message
                    if [[ -n "$tag_message" ]]; then
                        git tag -a "$tag_name" -m "$tag_message"
                        echo "\033[32mğŸ·ï¸ Created annotated tag: $tag_name\033[0m"
                    fi
                fi
                ;;
        esac
        return 0
    fi
    
    local selection=$(echo "$tags" | \
        while IFS='|' read -r tag commit_hash date; do
            printf "\033[33mğŸ·ï¸ %s\033[0m \033[90m%s\033[0m \033[36m(%s)\033[0m\n" "$tag" "$commit_hash" "$date"
        done | \
        fzf --ansi \
            --prompt "ğŸ·ï¸ Select tag: " \
            --header $'\033[36m>> ğŸ·ï¸ Press TAB to create new tag <<\033[0m' \
            --preview 'git show --color=always $(echo {} | awk "{print \$2}") 2>/dev/null' \
            --preview-window=right:60% \
            --bind 'tab:print-query' \
            --print-query)
    
    local query=$(echo "$selection" | head -1)
    local choice=$(echo "$selection" | tail -1)
    
    if [[ -z "$choice" && -n "$query" ]] || [[ "$choice" == "$query" ]]; then
        if [[ -n "$query" ]]; then
            local tag_name="${query// /-}"
            echo "\033[32mğŸ·ï¸ Creating tag: $tag_name\033[0m"
            git tag "$tag_name"
        fi
        return 0
    fi
    
    [[ -z "$choice" ]] && return 0
    
    local tag_name=$(echo "$choice" | awk '{print $2}')
    [[ -z "$tag_name" ]] && return 0
    
    local action=$(echo -e "ğŸ¯ Checkout tag\nğŸŒ¿ Create branch from tag\nğŸ“¤ Push tag to remote\nğŸ“¥ Pull tag from remote\nğŸ—‘ï¸ Delete tag\nğŸ“‹ Copy tag name\nğŸ‘ï¸ Show tag details\nğŸ·ï¸ Create new tag\nâŒ Cancel" | \
        fzf --prompt "ğŸ¯ Action for tag '$tag_name': ")
    
    case "$action" in
        "ğŸ¯ Checkout tag")
            echo "\033[32mğŸ¯ Checking out tag: $tag_name\033[0m"
            git checkout "$tag_name"
            ;;
        "ğŸŒ¿ Create branch from tag")
            echo "\033[33mğŸ’¡ Enter branch name for tag $tag_name:\033[0m"
            local branch_name=""
            vared branch_name
            if [[ -n "$branch_name" ]]; then
                branch_name="${branch_name// /-}"
                echo "\033[32mğŸŒ¿ Creating branch '$branch_name' from tag $tag_name\033[0m"
                git checkout -b "$branch_name" "$tag_name"
            fi
            ;;
        "ğŸ“¤ Push tag to remote")
            echo "\033[34mğŸ“¤ Pushing tag to remote: $tag_name\033[0m"
            git push origin "$tag_name"
            ;;
        "ğŸ“¥ Pull tag from remote")
            echo "\033[34mğŸ“¥ Fetching tags from remote...\033[0m"
            git fetch --tags
            ;;
        "ğŸ—‘ï¸ Delete tag")
            echo "\033[31mğŸ—‘ï¸ Deleting tag: $tag_name\033[0m"
            git tag -d "$tag_name"
            ;;
        "ğŸ“‹ Copy tag name")
            if command -v pbcopy >/dev/null 2>&1; then
                echo "$tag_name" | pbcopy
                echo "\033[32mğŸ“‹ Copied tag name to clipboard: $tag_name\033[0m"
            elif command -v xclip >/dev/null 2>&1; then
                echo "$tag_name" | xclip -selection clipboard
                echo "\033[32mğŸ“‹ Copied tag name to clipboard: $tag_name\033[0m"
            elif command -v xsel >/dev/null 2>&1; then
                echo "$tag_name" | xsel --clipboard --input
                echo "\033[32mğŸ“‹ Copied tag name to clipboard: $tag_name\033[0m"
            else
                echo "\033[33mğŸ“‹ Tag name: $tag_name\033[0m"
            fi
            ;;
        "ğŸ‘ï¸ Show tag details")
            git show "$tag_name" | less
            ;;
        "ğŸ·ï¸ Create new tag")
            echo "\033[33mğŸ’¡ Enter new tag name:\033[0m"
            local new_tag=""
            vared new_tag
            if [[ -n "$new_tag" ]]; then
                new_tag="${new_tag// /-}"
                git tag "$new_tag"
                echo "\033[32mğŸ·ï¸ Created tag: $new_tag\033[0m"
            fi
            ;;
    esac
}

git_reflog() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "\033[31mâŒ Not in a git repository\033[0m"
        return 1
    fi

    local reflog_entries=$(git reflog --format='%h|%gd|%gs|%cr' 2>/dev/null)
    
    if [[ -z "$reflog_entries" ]]; then
        echo "\033[33mâš ï¸ No reflog entries found\033[0m"
        return 0
    fi
    
    local selection=$(echo "$reflog_entries" | \
        while IFS='|' read -r hash ref action time; do
            printf "\033[33m%s\033[0m \033[36m%s\033[0m %s \033[90m(%s)\033[0m\n" "$hash" "$ref" "$action" "$time"
        done | \
        fzf --ansi \
            --prompt "ğŸ”„ Select reflog entry: " \
            --preview 'git show --color=always $(echo {} | awk "{print \$1}") 2>/dev/null' \
            --preview-window=right:60%)
    
    [[ -z "$selection" ]] && return 0
    
    local commit_hash=$(echo "$selection" | awk '{print $1}')
    local ref_name=$(echo "$selection" | awk '{print $2}')
    [[ -z "$commit_hash" ]] && return 0
    
    local action=$(echo -e "ğŸ¯ Checkout commit\nğŸŒ¿ Create branch from commit\nğŸ”„ Reset --hard to commit\nğŸ“ Reset --soft to commit\nğŸ’ Cherry-pick commit\nğŸ“‹ Copy commit hash\nğŸ‘ï¸ Show commit details\nâŒ Cancel" | \
        fzf --prompt "ğŸ¯ Action for '$ref_name' ($commit_hash): ")
    
    case "$action" in
        "ğŸ¯ Checkout commit")
            echo "\033[32mğŸ¯ Checking out commit: $commit_hash\033[0m"
            git checkout "$commit_hash"
            ;;
        "ğŸŒ¿ Create branch from commit")
            echo "\033[33mğŸ’¡ Enter branch name for commit $commit_hash:\033[0m"
            local branch_name=""
            vared branch_name
            if [[ -n "$branch_name" ]]; then
                branch_name="${branch_name// /-}"
                echo "\033[32mğŸŒ¿ Creating branch '$branch_name' from commit $commit_hash\033[0m"
                git checkout -b "$branch_name" "$commit_hash"
            fi
            ;;
        "ğŸ”„ Reset --hard to commit")
            echo "\033[31mâš ï¸  WARNING: This will PERMANENTLY DELETE all changes after commit $commit_hash!\033[0m"
            echo "\033[31mğŸ”¥ This action cannot be undone. Type 'DELETE' to confirm:\033[0m"
            local confirm=""
            vared confirm
            if [[ "$confirm" == "DELETE" ]]; then
                echo "\033[31mğŸ’¥ Performing hard reset to: $commit_hash\033[0m"
                git reset --hard "$commit_hash"
            else
                echo "\033[33mâŒ Reset cancelled\033[0m"
            fi
            ;;
        "ğŸ“ Reset --soft to commit")
            echo "\033[34mğŸ“ Soft resetting to commit: $commit_hash\033[0m"
            git reset --soft "$commit_hash"
            ;;
        "ğŸ’ Cherry-pick commit")
            echo "\033[35mğŸ’ Cherry-picking commit: $commit_hash\033[0m"
            git cherry-pick "$commit_hash"
            ;;
        "ğŸ“‹ Copy commit hash")
            if command -v pbcopy >/dev/null 2>&1; then
                echo "$commit_hash" | pbcopy
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            elif command -v xclip >/dev/null 2>&1; then
                echo "$commit_hash" | xclip -selection clipboard
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            elif command -v xsel >/dev/null 2>&1; then
                echo "$commit_hash" | xsel --clipboard --input
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            else
                echo "\033[33mğŸ“‹ Commit hash: $commit_hash\033[0m"
            fi
            ;;
        "ğŸ‘ï¸ Show commit details")
            git show "$commit_hash" | less
            ;;
    esac
}

# Enhanced git_branch with comparison options
git_branch() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "\033[31mâŒ Not in a git repository\033[0m"
        return 1
    fi

    local branches=$(git for-each-ref --format='%(refname:short)|%(committerdate:relative)|%(authorname)' refs/heads/ refs/remotes/ | \
        while IFS='|' read -r branch date author; do
            local color="\033[31m"
            local emoji="ğŸ”´"
            if [[ $date == *"minute"* ]] || [[ $date == *"hour"* ]] || [[ $date == *"day"* ]]; then
                color="\033[32m"
                emoji="ğŸŸ¢"
            elif [[ $date == *"week"* ]] || [[ $date == *"month"* ]]; then
                color="\033[33m"
                emoji="ğŸŸ¡"
            fi
            printf "%s%s %s\033[0m %s (%s by %s)\n" "$color" "$emoji" "$branch" "$branch" "$date" "$author"
        done | sort -k3 | \
        awk '/main|master/ {print; next} {rest = rest $0 "\n"} END {printf "%s", rest}')
    
    local current_branch=$(git branch --show-current)
    
    local selection=$(printf "%s\n" "$branches" | \
        fzf --ansi \
            --prompt "ğŸŒ¿ Select branch: " \
            --header $'\033[36m>> ğŸš€ Press TAB to create new branch with current query <<\033[0m' \
            --preview 'git log --oneline --graph --color=always $(echo {} | awk "{print \$3}") -- 2>/dev/null || echo "ğŸ“ No commits yet"' \
            --preview-window=right:50% \
            --with-nth=3.. \
            --bind 'tab:print-query' \
            --print-query)
    
    local query=$(echo "$selection" | head -1)
    local choice=$(echo "$selection" | tail -1)
    
    if [[ -z "$choice" && -n "$query" ]] || [[ "$choice" == "$query" ]]; then
        if [[ -n "$query" ]]; then
            local branch_name="${query// /-}"
            
            local creation_option=$(echo -e "ğŸš€ Create and switch\nğŸ’¾ Stash changes and create\nğŸ“ Commit changes and create\nğŸŒ¿ Create from current HEAD\nâŒ Cancel" | \
                fzf --prompt "ğŸ¯ How to create branch '$branch_name'? ")
            
            case "$creation_option" in
                "ğŸš€ Create and switch")
                    echo "\033[32mğŸš€ Creating and switching to branch: $branch_name\033[0m"
                    git checkout -b "$branch_name"
                    ;;
                "ğŸ’¾ Stash changes and create")
                    echo "\033[33mğŸ’¾ Stashing changes and creating branch: $branch_name\033[0m"
                    git stash push -m "Auto-stash before creating $branch_name"
                    git checkout -b "$branch_name"
                    ;;
                "ğŸ“ Commit changes and create")
                    echo "\033[34mğŸ“ Committing changes and creating branch: $branch_name\033[0m"
                    git add -A
                    git commit -m "WIP: Before creating branch $branch_name"
                    git checkout -b "$branch_name"
                    ;;
                "ğŸŒ¿ Create from current HEAD")
                    echo "\033[32mğŸŒ¿ Creating branch: $branch_name\033[0m"
                    git branch "$branch_name"
                    echo "\033[36mğŸ“ Branch '$branch_name' created. Use 'git checkout $branch_name' to switch.\033[0m"
                    ;;
            esac
        fi
        return 0
    fi
    
    [[ -z "$choice" ]] && return 0
    
    local branch_name=$(echo "$choice" | awk '{print $3}')
    [[ -z "$branch_name" ]] && return 0
    
    if [[ "$branch_name" == "$current_branch" ]]; then
        echo "\033[33mâš ï¸  Already on branch '$branch_name'\033[0m"
        return 0
    fi
    
    local action=$(echo -e "ğŸ”„ Switch to branch\nğŸ”€ Merge into current branch\nğŸ” Rebase current onto this\nğŸ” Compare with current branch\nğŸ” Compare with another branch\nğŸ“‹ Copy commit hash\nğŸ—‘ï¸ Delete branch\nâŒ Cancel" | \
        fzf --prompt "ğŸ¯ Action for '$branch_name': ")
    
    case "$action" in
        "ğŸ”„ Switch to branch")
            echo "\033[32mğŸ”„ Switching to branch: $branch_name\033[0m"
            git checkout "$branch_name"
            handle_merge_conflict
            ;;
        "ğŸ”€ Merge into current branch")
            echo "\033[34mğŸ”€ Merging '$branch_name' into current branch ($current_branch)\033[0m"
            git merge "$branch_name"
            handle_merge_conflict
            ;;
        "ğŸ” Rebase current onto this")
            echo "\033[35mğŸ” Rebasing current branch ($current_branch) onto '$branch_name'\033[0m"
            git rebase "$branch_name"
            handle_merge_conflict
            ;;
        "ğŸ” Compare with current branch")
            echo "\033[36mğŸ” Comparing '$branch_name' with current branch ($current_branch)\033[0m"
            git log --oneline --graph --color=always "$current_branch".."$branch_name" | less
            ;;
        "ğŸ” Compare with another branch")
            local other_branch=$(git branch -a --format='%(refname:short)' | grep -v "^$branch_name$" | \
                fzf --prompt "ğŸ” Compare '$branch_name' with: ")
            if [[ -n "$other_branch" ]]; then
                echo "\033[36mğŸ” Comparing '$branch_name' with '$other_branch'\033[0m"
                git log --oneline --graph --color=always "$other_branch".."$branch_name" | less
            fi
            ;;
        "ğŸ“‹ Copy commit hash")
            local commit_hash=$(git rev-parse "$branch_name")
            if command -v pbcopy >/dev/null 2>&1; then
                echo "$commit_hash" | pbcopy
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            elif command -v xclip >/dev/null 2>&1; then
                echo "$commit_hash" | xclip -selection clipboard
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            elif command -v xsel >/dev/null 2>&1; then
                echo "$commit_hash" | xsel --clipboard --input
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            else
                echo "\033[33mğŸ“‹ Commit hash: $commit_hash\033[0m"
            fi
            ;;
        "ğŸ—‘ï¸ Delete branch")
            if [[ "$branch_name" =~ ^(main|master)$ ]]; then
                echo "\033[31mâŒ Cannot delete main/master branch\033[0m"
                return 1
            fi
            echo "\033[31mğŸ—‘ï¸ Deleting branch: $branch_name\033[0m"
            git branch -d "$branch_name" 2>/dev/null || git branch -D "$branch_name"
            ;;
    esac
}

# Enhanced git_history with comparison options
git_history() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "\033[31mâŒ Not in a git repository\033[0m"
        return 1
    fi

    local commit=$(git log --oneline --graph --color=always \
        --format="%C(yellow)%h%C(reset) %C(white)%s%C(reset) %C(blue)by %an%C(reset) %C(green)%ar%C(reset)%C(auto)%d%C(reset)" \
        --all | \
        sed 's/tag: /ğŸ·ï¸ /g' | \
        fzf --ansi \
            --prompt "ğŸ“‹ Select commit: " \
            --preview 'git show --color=always $(echo {} | grep -o "[a-f0-9]\{7,\}" | head -1)' \
            --preview-window=right:60% \
            --bind 'ctrl-d:preview-page-down,ctrl-u:preview-page-up')
    
    [[ -z "$commit" ]] && return 0
    
    local commit_hash=$(echo "$commit" | grep -o "[a-f0-9]\{7,\}" | head -1)
    [[ -z "$commit_hash" ]] && return 0
    
    local action=$(echo -e "ğŸ¯ Checkout commit\nğŸŒ¿ Create branch from commit\nğŸ”„ Revert commit\nğŸ’¥ Reset --hard to commit\nğŸ“ Reset --soft to commit\nğŸ’ Cherry-pick commit\nğŸ·ï¸ Create tag from commit\nğŸ” Compare with another commit\nğŸ” Compare with branch\nğŸ“‹ Copy commit hash\nğŸ‘ï¸ Show commit details\nâŒ Cancel" | \
        fzf --prompt "ğŸ¯ Action for commit '$commit_hash': ")
    
    case "$action" in
        "ğŸ¯ Checkout commit")
            echo "\033[32mğŸ¯ Checking out commit: $commit_hash\033[0m"
            git checkout "$commit_hash"
            ;;
        "ğŸŒ¿ Create branch from commit")
            echo "\033[36mğŸŒ¿ Creating new branch from commit: $commit_hash\033[0m"
            echo "\033[33mğŸ’¡ Enter the name for the new branch (will be created from $commit_hash):\033[0m"
            local branch_input=""
            vared branch_input
            if [[ -n "$branch_input" ]]; then
                local branch_name="${branch_input// /-}"
                echo "\033[32mğŸš€ Creating and switching to branch '$branch_name' from commit $commit_hash\033[0m"
                git checkout -b "$branch_name" "$commit_hash"
            else
                echo "\033[31mâŒ Branch creation cancelled - no name provided\033[0m"
            fi
            ;;
        "ğŸ”„ Revert commit")
            echo "\033[33mğŸ”„ Reverting commit: $commit_hash\033[0m"
            git revert "$commit_hash"
            handle_merge_conflict
            ;;
        "ğŸ’¥ Reset --hard to commit")
            echo "\033[31mâš ï¸  WARNING: This will PERMANENTLY DELETE all changes after commit $commit_hash!\033[0m"
            echo "\033[31mğŸ”¥ This action cannot be undone. Type 'DELETE' to confirm:\033[0m"
            local confirm=""
            vared confirm
            if [[ "$confirm" == "DELETE" ]]; then
                echo "\033[31mğŸ’¥ Performing hard reset to: $commit_hash\033[0m"
                git reset --hard "$commit_hash"
            else
                echo "\033[33mâŒ Reset cancelled - confirmation not received\033[0m"
            fi
            ;;
        "ğŸ“ Reset --soft to commit")
            echo "\033[34mğŸ“ Soft resetting to commit: $commit_hash (keeping changes staged)\033[0m"
            git reset --soft "$commit_hash"
            ;;
        "ğŸ’ Cherry-pick commit")
            echo "\033[35mğŸ’ Cherry-picking commit: $commit_hash\033[0m"
            git cherry-pick "$commit_hash"
            handle_merge_conflict
            ;;
        "ğŸ·ï¸ Create tag from commit")
            echo "\033[36mğŸ·ï¸ Creating tag from commit: $commit_hash\033[0m"
            echo "\033[33mğŸ’¡ Enter tag name (will tag commit $commit_hash):\033[0m"
            local tag_input=""
            vared tag_input
            if [[ -n "$tag_input" ]]; then
                local tag_name="${tag_input// /-}"
                echo "\033[32mğŸ·ï¸ Creating tag '$tag_name' at commit $commit_hash\033[0m"
                git tag "$tag_name" "$commit_hash"
            else
                echo "\033[31mâŒ Tag creation cancelled - no name provided\033[0m"
            fi
            ;;
        "ğŸ” Compare with another commit")
            local other_commit=$(git log --oneline --format="%h %s" | \
                fzf --prompt "ğŸ” Compare '$commit_hash' with: " | awk '{print $1}')
            if [[ -n "$other_commit" ]]; then
                echo "\033[36mğŸ” Comparing commits $commit_hash and $other_commit\033[0m"
                git diff --color=always "$other_commit" "$commit_hash" | less
            fi
            ;;
        "ğŸ” Compare with branch")
            local branch=$(git branch -a --format='%(refname:short)' | \
                fzf --prompt "ğŸ” Compare '$commit_hash' with branch: ")
            if [[ -n "$branch" ]]; then
                echo "\033[36mğŸ” Comparing commit $commit_hash with branch $branch\033[0m"
                git diff --color=always "$branch" "$commit_hash" | less
            fi
            ;;
        "ğŸ“‹ Copy commit hash")
            if command -v pbcopy >/dev/null 2>&1; then
                echo "$commit_hash" | pbcopy
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            elif command -v xclip >/dev/null 2>&1; then
                echo "$commit_hash" | xclip -selection clipboard
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            elif command -v xsel >/dev/null 2>&1; then
                echo "$commit_hash" | xsel --clipboard --input
                echo "\033[32mğŸ“‹ Copied commit hash to clipboard: $commit_hash\033[0m"
            else
                echo "\033[33mğŸ“‹ Commit hash: $commit_hash\033[0m"
            fi
            ;;
        "ğŸ‘ï¸ Show commit details")
            git show "$commit_hash" | less
            ;;
    esac
}

# Register all functions
zle -N git_branch git_branch
zle -N git_history git_history
zle -N git_stash git_stash
zle -N git_stage git_stage
zle -N git_tags git_tags
zle -N git_reflog git_reflog
